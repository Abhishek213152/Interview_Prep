{"title": "Colorful Block Arrangement", "difficulty": "Easy", "category": "backtracking", "description": "You have a row of N empty slots. You need to fill these slots with colored blocks.  You have three colors available: Red (R), Green (G), and Blue (B).  However, you are not allowed to place two blocks of the same color next to each other. Find all possible arrangements of colored blocks that satisfy this constraint.  Return the arrangements as a list of strings, where each string represents an arrangement.", "examples": [{"input": "2", "output": "[\"RG\", \"RB\", \"GR\", \"GB\", \"BR\", \"BG\"]", "explanation": "With 2 slots, all possible arrangements avoiding consecutive same colors are shown."}, {"input": "3", "output": "[\"RGB\", \"RBG\", \"GRB\", \"GBR\", \"BRG\", \"BGR\"]", "explanation": "With 3 slots, all possible arrangements avoiding consecutive same colors are shown.\n\n\nConstraints:\n- 1 <= N <= 5  (This keeps the problem easy.  Larger N values would drastically increase the solution space.)\n- Time/space complexity is not strictly enforced for this easy problem, but an efficient backtracking solution is preferred."}], "constraints": ["- 1 <= N <= 5  (This keeps the problem easy.  Larger N values would drastically increase the solution space.)", "- Time/space complexity is not strictly enforced for this easy problem, but an efficient backtracking solution is preferred."], "function_signature": {"java": "public List<String> coloredBlockArrangements(int n) { // Your code here }", "cpp": "std::vector<std::string> coloredBlockArrangements(int n) { // Your code here }", "python": "def colored_block_arrangements(n): # Your code here\n    pass"}, "id": "44906f796d9637cdb0812b57d67bb06a"}