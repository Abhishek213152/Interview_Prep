{"title": "Recursive Labyrinth Escape with Variable Walls", "difficulty": "Hard", "category": "recursion", "description": "You are designing a robot to navigate a labyrinth represented as a 2D grid.  The labyrinth's walls are dynamic: each cell in the grid contains a number representing the \"wall state\" at that location. A wall state of 0 means the cell is open, while any other positive integer represents a closed wall.  Crucially, the wall state changes *recursively* after the robot passes through it.  If the robot moves into a cell with wall state 'x', that cell's state becomes 'x-1'. If it reaches 0, it remains 0.  The robot starts at coordinates (0,0) and wants to reach the destination (rows-1, cols-1). Find the minimum number of moves required to reach the destination, or return -1 if it's impossible. The robot can only move up, down, left, or right.", "examples": [{"input": "`grid = [[2,1,0],[1,2,1],[0,1,3]]`", "output": "`7`", "explanation": "- Start at (0,0).  The cell's state changes to 1.\n   - Move right to (0,1). The cell's state changes to 0.\n   - Move right to (0,2). The cell's state remains 0.\n   - Move down to (1,2). The cell's state changes to 0.\n   - Move down to (2,2). The cell's state changes to 2.\n   - Move left to (2,1). The cell's state changes to 0.\n   - Move up to (1,1). The cell's state changes to 1.\n   - Move up to (0,1). The cell's state remains 0.\n   - Move right to (0,2). The cell's state remains 0.\n   - Move down to (1,2). The cell's state remains 0.\n   - Move down to (2,2).  The cell's state changes to 1.\n   - Move left to (2,1). The cell's state remains 0.\n   - Move up to (1,1). The cell's state remains 0.\n   - Move right to (1,2). The cell's state remains 0.\n   - Move down to (2,2). The cell's state changes to 0.\n   Total moves: 7"}, {"input": "`grid = [[1,1],[1,1]]`", "output": "`-1`", "explanation": "The robot gets trapped. It can't reach the destination (1,1) due to the recursive wall state changes.\n\n\nConstraints:\n- `1 <= rows, cols <= 10` (grid dimensions)\n- `0 <= grid[i][j] <= 10` (wall state values)\n- Time complexity:  O(rows * cols * (max_wall_state + 1)^ (rows*cols)) -  This is a very loose upper bound, the actual runtime will depend heavily on the grid.  Optimizations are highly encouraged.\n- Space complexity: O(rows * cols) - Due to the recursive nature and potential need to track visited cells.  This does not include the implicit space used by the recursion stack.  The space complexity of the recursive solution is directly proportional to the branching factor (number of possible moves from a cell), which is at most 4 and multiplied by the depth of the search."}], "constraints": ["- `1 <= rows, cols <= 10` (grid dimensions)", "- `0 <= grid[i][j] <= 10` (wall state values)", "- Time complexity:  O(rows * cols * (max_wall_state + 1)^ (rows*cols)) -  This is a very loose upper bound, the actual runtime will depend heavily on the grid.  Optimizations are highly encouraged.", "- Space complexity: O(rows * cols) - Due to the recursive nature and potential need to track visited cells.  This does not include the implicit space used by the recursion stack.  The space complexity of the recursive solution is directly proportional to the branching factor (number of possible moves from a cell), which is at most 4 and multiplied by the depth of the search."], "function_signature": {"java": "public int minMoves(int[][] labyrinth) { // Your code here }", "cpp": "int minMoves(vector<vector<int>>& labyrinth) { // Your code here }", "python": "def min_moves(labyrinth): # Your code here\n    pass"}, "id": "6b41367851db4dbdb7071ec4fc9dbb11"}