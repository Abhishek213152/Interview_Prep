{"title": "Optimal Satellite Network Deployment", "difficulty": "Hard", "category": "greedy", "description": "You are tasked with deploying a network of satellites to provide global coverage.  You are given a list of potential satellite deployment locations, represented as points (x, y, z) in 3D space. Each satellite has a fixed coverage radius `r`.  However, satellites interfere with each other if their spheres of coverage overlap.  Your goal is to select a subset of satellites to deploy such that:\n\n1.  The entire globe (represented by a large bounding sphere with radius `R` centered at the origin) is covered.  Every point within the bounding sphere must be within the coverage radius of at least one deployed satellite.\n2.  The number of deployed satellites is minimized.\n\nThe input is a list of tuples, each representing a satellite location (x, y, z), and the coverage radius `r` and the bounding sphere radius `R`.  Your algorithm should return the coordinates of the selected satellites.  Assume that the satellites can be placed at any point within the specified coordinates (no need to deal with discrete grid placement).", "examples": [{"input": "`satellites = [(10,0,0), (0,10,0), (0,0,10), (-10,0,0), (0,-10,0), (0,0,-10)], r = 10, R = 15`", "output": "`[(10,0,0), (0,10,0), (0,0,10)]`  (or any other combination of 3 satellites that cover the bounding sphere)", "explanation": "Three satellites strategically placed along the axes are sufficient to cover the entire bounding sphere.  Deploying more would be redundant."}, {"input": "`satellites = [(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5)], r = 1, R = 5`", "output": "`[(1,1,1), (3,3,3), (5,5,5)]` (or a similar set covering the sphere)", "explanation": "A greedy approach choosing satellites that maximize newly covered area is required. Simply picking the closest isn't sufficient due to interference.\n\n\nConstraints:\n- `0 < r <= R`\n- The number of satellites will be less than 1000.\n- Coordinates (x, y, z) are floating-point numbers.\n- Time complexity should be better than O(n^3), where n is the number of satellites.  A greedy O(n log n) or better solution is preferred.  Space complexity should be O(n).\n\n\nNote:  This problem requires a sophisticated greedy strategy.  Simple heuristics like selecting satellites closest to the origin may fail. Consider strategies that account for coverage overlap and maximize the newly covered volume with each addition.  You will need to devise a method to efficiently check if a given set of satellites covers the entire bounding sphere.  Consider using spatial partitioning or other efficient data structures to optimize the coverage check."}], "constraints": ["- `0 < r <= R`", "- The number of satellites will be less than 1000.", "- Coordinates (x, y, z) are floating-point numbers.", "- Time complexity should be better than O(n^3), where n is the number of satellites.  A greedy O(n log n) or better solution is preferred.  Space complexity should be O(n)."], "function_signature": {"java": "public List<Tuple3<Double, Double, Double>> selectSatellites(List<Tuple3<Double, Double, Double>> potentialLocations, double r, double R) { // Your code here }", "cpp": "std::vector<std::tuple<double, double, double>> selectSatellites(const std::vector<std::tuple<double, double, double>>& potentialLocations, double r, double R) { // Your code here }", "python": "def select_satellites(potential_locations, r, R): # Your code here\n    pass"}, "id": "0a586cb11c13b3a5360d637317d6b1db"}