{"title": "Recursive Maze Escape with Variable Walls", "difficulty": "Medium", "category": "recursion", "description": "You are given a maze represented as a 2D boolean array where `true` represents a wall and `false` represents an open path.  The maze is dynamic; some walls can be temporarily removed at a cost. The cost of removing a wall is represented by a separate 2D integer array of the same dimensions. You are given a starting position (row, col) and an ending position (targetRow, targetCol).  Find the minimum cost to escape the maze using recursion, where you can move up, down, left, or right.  You can only remove a wall once per path.", "examples": [{"input": "`maze = [[False, True, False], [False, True, False], [True, False, False]]`\n   `costs = [[0, 5, 0], [0, 2, 0], [3, 0, 0]]`\n   `start = (0, 0)`\n   `end = (2, 2)`", "output": "3", "explanation": "The optimal path is (0,0) -> (0,2) -> (1,2) -> (2,2).  The wall at (0,1) is not removed, and the wall at (2,0) is removed at a cost of 3."}, {"input": "`maze = [[False, True, True], [True, False, True], [True, True, False]]`\n   `costs = [[0, 10, 10], [10, 0, 1], [10, 10, 0]]`\n   `start = (0, 0)`\n   `end = (2, 2)`", "output": "2", "explanation": "The optimal path is (0,0) -> (1,1) -> (2,2). The wall at (1,0) is removed for a cost of 10, and then the path to (2,2) is taken. This is a better path than removing two other walls which would be more expensive.\n\nConstraints:\n- `1 <= maze.length <= 10`\n- `1 <= maze[0].length <= 10`\n- `maze` and `costs` are square matrices of the same size.\n- `start` and `end` are valid coordinates within the maze.\n- `costs[i][j] >= 0` for all `i, j`.\n- Time complexity should be less than O(2^(m*n)), where m and n are dimensions of the maze (this is a loose upper bound to prevent brute force solutions).\n- Space complexity should be polynomial with respect to m and n.\n\n\nNote:  This problem requires a recursive approach with backtracking and efficient cost tracking to find the minimal cost.  A simple recursive exploration without optimization will likely exceed the time complexity constraint.  Consider using memoization or dynamic programming techniques to improve performance."}], "constraints": ["- `1 <= maze.length <= 10`", "- `1 <= maze[0].length <= 10`", "- `maze` and `costs` are square matrices of the same size.", "- `start` and `end` are valid coordinates within the maze.", "- `costs[i][j] >= 0` for all `i, j`.", "- Time complexity should be less than O(2^(m*n)), where m and n are dimensions of the maze (this is a loose upper bound to prevent brute force solutions).", "- Space complexity should be polynomial with respect to m and n."], "function_signature": {"java": "public int minCostEscape(boolean[][] maze, int[][] cost, int row, int col, int targetRow, int targetCol, boolean[][] visited) { // Your code here }", "cpp": "int minCostEscape(const vector<vector<bool>>& maze, const vector<vector<int>>& cost, int row, int col, int targetRow, int targetCol, vector<vector<bool>>& visited) { // Your code here }", "python": "def min_cost_escape(maze, cost, row, col, target_row, target_col, visited): # Your code here\n    pass"}, "id": "d17363e9e6de149846e39e5d7bf2c712"}