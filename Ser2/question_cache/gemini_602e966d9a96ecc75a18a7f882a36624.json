{"title": "Optimal City Route with Limited Fuel and Recharge Stations", "difficulty": "Medium", "category": "graphs", "description": "You are given a map represented as a weighted, undirected graph where nodes represent cities and edges represent roads with associated distances (weights).  Each city has a fuel capacity denoted by a non-negative integer.  Your task is to find the shortest route from a starting city (source) to a destination city (target) given that you have a limited initial fuel capacity and you can only recharge your fuel at specific recharge stations (cities marked with a 'R' flag).  Your fuel consumption is equal to the distance traveled on each road.  If your fuel drops to zero during travel, you cannot continue.  You must find the shortest path, or return -1 if no path exists.", "examples": [{"input": "Graph: {\n       'A': {'B': 10, 'C': 15},\n       'B': {'A': 10, 'D': 5, 'R': 20},\n       'C': {'A': 15, 'E': 12},\n       'D': {'B': 5, 'E': 8, 'F': 7},\n       'E': {'C': 12, 'D': 8, 'F': 6},\n       'F': {'D': 7, 'E': 6, 'R': 15}\n   },\n   source: 'A',\n   target: 'F',\n   initial_fuel: 25,\n   recharge_stations: ['B', 'F']", "output": "32", "explanation": "The shortest path is A -> B (fuel: 25-10=15) -> D (fuel: 15-5=10) -> E (fuel: 10-8=2) -> F (fuel: 22-6=16).  Recharge at B and F. Total Distance: 10+5+8+6 = 29.\n   Note:  The explanation is simplified for demonstration, a correct solution would use Dijkstra's algorithm considering fuel constraints."}, {"input": "Graph: {\n       'A': {'B': 5, 'C': 10},\n       'B': {'A': 5, 'D': 7},\n       'C': {'A': 10, 'E': 15},\n       'D': {'B': 7, 'E': 3},\n       'E': {'C': 15, 'D': 3}\n   },\n   source: 'A',\n   target: 'E',\n   initial_fuel: 10,\n   recharge_stations: []", "output": "-1", "explanation": "There is no path from A to E with only 10 initial fuel and no recharge stations.\n\n\nConstraints:\n- The graph will be represented as an adjacency dictionary.\n- The number of nodes (cities) will be less than or equal to 100.\n- Edge weights (distances) will be positive integers.\n- Initial fuel capacity will be a non-negative integer.\n- Recharge stations will be a list of city labels.\n- Time complexity should be ideally O(E log V), where E is the number of edges and V is the number of vertices (using Dijkstra's adaptation).\n- Space complexity should be O(V) + O(E)  for storing graph and other data structures."}], "constraints": ["- The graph will be represented as an adjacency dictionary.", "- The number of nodes (cities) will be less than or equal to 100.", "- Edge weights (distances) will be positive integers.", "- Initial fuel capacity will be a non-negative integer.", "- Recharge stations will be a list of city labels.", "- Time complexity should be ideally O(E log V), where E is the number of edges and V is the number of vertices (using Dijkstra's adaptation).", "- Space complexity should be O(V) + O(E)  for storing graph and other data structures."], "function_signature": {"java": "public int shortestRoute(Map<Integer, City> graph, int source, int target, int initialFuel) { // Your code here }", "cpp": "int shortestRoute(const std::map<int, City>& graph, int source, int target, int initialFuel) { // Your code here }", "python": "def shortest_route(graph, source, target, initial_fuel): # Your code here\n    pass"}, "id": "602e966d9a96ecc75a18a7f882a36624"}