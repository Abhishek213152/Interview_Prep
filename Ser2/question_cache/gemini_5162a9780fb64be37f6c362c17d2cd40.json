{"title": "Optimal Parcel Distribution for Drone Delivery", "difficulty": "Medium", "category": "greedy", "description": "You are tasked with optimizing drone delivery routes for a set of parcels.  Each parcel `i` has a weight `w_i` and a destination coordinate `(x_i, y_i)`. Your drone has a maximum weight capacity `C`.  The drone starts at the origin (0, 0).  The cost of delivering a parcel is the Euclidean distance from the drone's current location to the parcel's destination.  The drone can only carry parcels whose total weight is less than or equal to `C`.  Design an algorithm to find a sequence of parcel deliveries that minimizes the total distance traveled by the drone, ensuring that no parcel exceeds the weight limit at any point.", "examples": [{"input": "`C = 10`, `parcels = [(5, (1,2)), (3, (3,4)), (7, (5,6)), (2, (2,1))]`  (weight, (x,y))", "output": "`20.36` (approximately)", "explanation": "The optimal sequence might be [(5,(1,2)), (3,(3,4)), (2,(2,1))], then return to origin.  The distance calculation would be approximately: sqrt(1^2 + 2^2) + sqrt((3-1)^2 + (4-2)^2) + sqrt((2-3)^2 + (1-4)^2) + sqrt(3^2 + 4^2) which is roughly 20.36"}, {"input": "`C = 5`, `parcels = [(2, (1,1)), (1, (2,2)), (3, (3,3)), (1,(4,4))]`", "output": "`7.66` (approximately)", "explanation": "The drone can only carry parcels with a total weight of 5 or less. One possible optimal path is to deliver (2,(1,1)), (1,(2,2)), (1,(4,4)) and then return to origin.  The total distance will be approximately sqrt(2) + sqrt(2) + sqrt(5) + sqrt(16+16) which is roughly 7.66\n\n\nConstraints:\n- `1 <= C <= 100`\n- `1 <= len(parcels) <= 20`\n- `1 <= w_i <= C` for all parcels `i`\n- `0 <= x_i, y_i <= 100` for all parcels `i`\n- The solution should have a time complexity of at most O(n! * n), where n is the number of parcels (although a truly optimal solution is NP-hard). A greedy heuristic that aims for near-optimal solutions is acceptable within this time complexity.\n- Floating-point precision is acceptable.  You do not need to account for minor differences due to floating-point arithmetic."}], "constraints": ["- `1 <= C <= 100`", "- `1 <= len(parcels) <= 20`", "- `1 <= w_i <= C` for all parcels `i`", "- `0 <= x_i, y_i <= 100` for all parcels `i`", "- The solution should have a time complexity of at most O(n! * n), where n is the number of parcels (although a truly optimal solution is NP-hard). A greedy heuristic that aims for near-optimal solutions is acceptable within this time complexity.", "- Floating-point precision is acceptable.  You do not need to account for minor differences due to floating-point arithmetic."], "function_signature": {"java": "public double minDeliveryDistance(double[][] parcels, double capacity) { // Your code here }", "cpp": "double minDeliveryDistance(const std::vector<std::tuple<double, double, double>>& parcels, double capacity) { // Your code here }", "python": "def min_delivery_distance(parcels, capacity): # Your code here\n    pass"}, "id": "5162a9780fb64be37f6c362c17d2cd40"}